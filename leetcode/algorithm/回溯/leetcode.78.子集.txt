==== leetcode.78.子集 ====
* 题目描述：
给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。
解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

* 输入描述：
第一行 数组长度n
第二行 n个整数
* 输出描述：
每行一个子集，空输出null。

==== 示例 ====
示例1：
输入：
3
1 2 3
输出：
null
1
2
1 2
3
1 3
2 3
1 2 3
---------------
示例1：
输入：
1
0
输出：
null
0
============
解题：

---------------------迭代解------------------------

记原序列中元素的总数为 n。原序列中的每个数字 a_i的状态可能有两种，
即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，
那么每一个子集可以对应一个长度为 n 的 0/1 序列，第 i 位表示 a_i是否在子集中。
例如，n = 3，a = { 5, 2, 9 }时：
0/1 序列    子集        0/1 序列对应的二进制数
000000	    {}	            0
001001	    {9}	            1
010010	    {2}	            2
011011	    {2,9}	        3
100100	    {5}	            4
101101	    {5,9}	        5
110110	    {5,2}	        6
111111	    {5,2,9}	        7

可以发现 0/1 序列对应的二进制数正好从 0 到 2^n - 1。我们可以枚举 mask∈[0, 2^n−1]，
mask 的二进制表示是一个 0/1 序列，我们可以按照这个 0/1 序列在原集合当中取数。
当我们枚举完所有 2^n个 mask，我们也就能构造出所有的子集。


---------------------递归解------------------------
采用递归回溯的思想，每个位置的数都有选和不选两种可能，
那我们就在遍历每个数的时候先选这个数然后进行下一步，
当下一步结果返回的时候即将当前的数弹出，再次进行下一步，
每次当遍历到最后一个数字后将当前结果加入集合，这样就能达到遍历所有结果的情况。





通过率：100%