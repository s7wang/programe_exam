==== offer.07.重建二叉树 ====
* 题目描述：
输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

* 输入描述：
第一行 m代表两个遍历序列长度（树的节点数量）；
第二行m个整数，代表前序遍历序列；
第三行n个整数，代表中序遍历序列。

* 输出描述：
树的层序遍历结果

==== 示例 ====
示例1：
输入：
5
3 9 20 15 7
9 3 15 20 7
输出：
3 9 20 null null 15 7
============
解题：
二叉树前序遍历的顺序为：
先遍历根节点；随后递归地遍历左子树；最后递归地遍历右子树。

二叉树中序遍历的顺序为：
先递归地遍历左子树；随后遍历根节点；最后递归地遍历右子树。

---------------------递归解------------------------
对于任意一颗树而言，前序遍历的形式总是：
    [根节点, [左子树的前序遍历结果], [右子树的前序遍历结果]]
即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是
    [[左子树的中序遍历结果], 根节点, [右子树的中序遍历结果]]
只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。
由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。
这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，
我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。

具体做法就是先序遍历是 根左右 中序是 左根右
所以先通过先序序列第一个找出整个根节点 然后定位根节点在中序序列的位置
将中序划分为左右两边分别构建左子树和右子树
新左子树的前序范围：原根节点的下一个开始 长度为 中序左边序列长度
新左子树的中序范围：根节点左边序列
新右子树的前序范围：原根节点的中序左边序列长度+1位置开始 长度为 中序右边序列长度
新右子树的中序范围：根节点右边序列

按照这种方法递归就可以完成树的构建
---------------------迭代解------------------------
迭代法是一种非常巧妙的实现方法。
对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：
 * v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即 v；
 * u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。
   如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。
   如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点u_a，那么 v 就是u_a的右儿子。
我们以树
        3
       / \
      9  20
     /  /  \
    8  15   7
   / \
  5  10
 /
4
为例，它的前序遍历和中序遍历分别为
preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]
inorder = [4, 5, 8, 10, 9, 3, 15, 20, 7]
初始化：preorder[0] 就是3构建根节点入栈，index指向inorder初始化为0；
开始遍历preorder，preorder[1]=9;栈顶3不等于4，构建栈顶节点3的左节点9，并将新节点入栈，此时：
stack:3 9
index=0;
继续；preorder[2]=8;栈顶9不等于4,构建栈顶节点9的左节点8，并将新节点入栈，此时：
stack:3 9 8
index=0;
继续；preorder[3]=5;栈顶8不等于4,构建栈顶节点8的左节点5，并将新节点入栈，此时：
stack:3 9 8 5
index=0;
继续；preorder[4]=4;栈顶5不等于4,构建栈顶节点5的左节点4，并将新节点入栈，此时：
stack:3 9 8 5 4
index=0;
继续；preorder[5]=10;栈顶4等于4,开始弹栈移动index：
stack:3 9 8 5 ----> stack:3 9 8 ----> stack:3 9 
index=1;            index=2;          index=3;
此时栈顶9不等于 inorder[3]=10；所以当前preorder[5]=10为最后一个弹出节点8的右节点；
构建8的右节点10，将新的右节点入栈此时：
stack:3 9 10
index=3;
用这种方法就能构建出完整的树。
通过率：100%